import base64
import requests
from django.shortcuts import render, redirect
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse, HttpResponse
import json
import re # Import the regular expression module

# --- CONFIGURATION ---
# IMPORTANT: Ensure your FastAPI is running on this port (e.g., 8000 for Django, 8001 for FastAPI)
FASTAPI_URL = "http://127.0.0.1:8001" 

# --- UTILITY FUNCTION ---
def extract_json_from_text(text):
    """
    Attempts to extract and parse a valid JSON object from a string
    that might contain conversational text or wrappers.
    """
    # Use regex to find the first block that looks like a JSON dictionary: { ... }
    # This is a basic, lenient search for anything between the first curly braces.
    match = re.search(r'\{.*\}', text, re.DOTALL)
    
    if match:
        json_content = match.group(0)
        try:
            # Attempt to parse the extracted content
            return json.loads(json_content)
        except json.JSONDecodeError:
            # Extracted content was not valid JSON
            return None
    return None

# --- VIEWS ---

def home(request):
    """Renders the home page with the interview configuration form."""
    return render(request, "home.html")


# Django views.py (CORRECTED)

def start_interview(request):
    if request.method == "POST":
        # 1. Gather all new dynamic parameters from the form
        role = request.POST.get("role", "Software Engineer")
        level = request.POST.get("level", "Mid-Level")
        focus = request.POST.get("focus", "Mix")
        mode = request.POST.get("mode", "Detailed|30")
        jd_text = request.POST.get("jd_text", "")

        # 2. Call FastAPI /start_session (THE CORRECT ENDPOINT)
        try:
            r = requests.post(
                f"{FASTAPI_URL}/start_session", 
                data={
                    "role": role,
                    "level": level,
                    "focus": focus,
                    "mode": mode,
                    "jd_text": jd_text
                }
            )
            r.raise_for_status()
            
            data = r.json()
            session_id = data.get("session_id")
            # This is the short, controlled first question generated by FastAPI's /start_session
            first_question = data.get("first_question", "Welcome! Tell me about yourself.") 
            
        except requests.exceptions.RequestException as e:
            print(f"FASTAPI CONNECTION ERROR: {e}")
            first_question = f"Error: Could not connect to backend ({FASTAPI_URL}). Is FastAPI running? {e}"
            session_id = "ERROR"

        # 3. Store the critical session data
        request.session["session_id"] = session_id
        request.session["current_question"] = first_question
        request.session["session_mode"] = mode 
        
        #  store dynamic role & other attributes for frontend
        request.session["role"] = role
        request.session["level"] = level
        request.session["focus"] = focus
        
        return redirect("/interview/")

    return redirect("/")



def interview(request):
    question = request.session.get("current_question", "Please start a new session.")
    session_id = request.session.get("session_id", "ERROR")
    session_mode = request.session.get("session_mode", "Detailed|30")

    return render(
        request,
        "interview.html",
        {
            "question": question,
            "session_id": session_id,
            "session_mode": session_mode,

            # THESE MUST BE PASSED FOR SIDEBAR
            "role": request.session.get("role", "Unknown Role"),
            "level": request.session.get("level", "—"),
            "focus": request.session.get("focus", "—"),
        }
    )




@csrf_exempt
def submit_answer(request):
    """
    Handles form submission of audio.
    Sends the audio and the session_id to the FastAPI /submit_response endpoint.
    Retrieves the full response (evaluation + next question) and returns it as JSON.
    """
    if request.method == "POST":
        session_id = request.POST.get("session_id")
        audio_b64 = request.POST.get("audio_data")

        if not session_id or not audio_b64:
            return JsonResponse({"error": "Missing session ID or audio data."}, status=400)

        # 1. Decode audio data (Base64)
        try:
            # We assume audio_b64 is a data URI like "data:audio/webm;base64,..."
            header, encoded = audio_b64.split(",", 1)
            audio_data = base64.b64decode(encoded)
        except ValueError:
            return JsonResponse({"error": "Invalid base64 audio data."}, status=400)

        # 2. Send the audio file and session_id to FastAPI /submit_response
        try:
            r = requests.post(
                f"{FASTAPI_URL}/submit_response",
                files={"audio": ("answer.webm", audio_data, "audio/webm")},
                data={"session_id": session_id}
            )
            r.raise_for_status() # Raise exception for bad status codes (4xx or 5xx)
            
            fastapi_response_data = None
            
            # --- CRITICAL FIX: Attempt to extract and parse JSON ---
            try:
                # FIRST ATTEMPT: Try to parse it as clean JSON (the correct way)
                fastapi_response_data = r.json() 
            except json.JSONDecodeError:
                # SECOND ATTEMPT: If it fails, use the extraction logic
                print(f"JSON DECODE FAILED. Attempting extraction from: {r.text[:50]}...")
                fastapi_response_data = extract_json_from_text(r.text)
            
            
            if fastapi_response_data is None:
                # If both attempts failed, return the original error message
                print(f"JSON EXTRACTION FAILED. LLM output was invalid: {r.text[:200]}...")
                return JsonResponse({
                    "error": "FastAPI returned an invalid response (not JSON). Check FastAPI console for errors.",
                    "details": r.text[:50] # Send a snippet of the bad response back for debugging
                }, status=500)
            
            # 4. If JSON is successfully retrieved, update session and return it
            if 'new_question' in fastapi_response_data:
                request.session["current_question"] = fastapi_response_data['new_question']
                
            return JsonResponse(fastapi_response_data)

        except requests.exceptions.RequestException as e:
            # This handles connection errors
            return JsonResponse({"error": f"Failed to connect to FastAPI /submit_response: {e}"}, status=500)
    
    return JsonResponse({"error": "Invalid method."}, status=405)
    # --- END INTERVIEW AND FEEDBACK LOGIC ---

@csrf_exempt
def end_interview(request):
    if request.method != "POST":
        return JsonResponse({"error": "Invalid method"}, status=405)

    try:
        data = json.loads(request.body.decode("utf-8"))
        session_id = data.get("session_id")
        request.session["session_id"] = session_id
    except:
        return JsonResponse({"error": "Missing session_id"}, status=400)

    try:
        r = requests.post(
            f"{FASTAPI_URL}/end_interview",
            json={"session_id": session_id}
        )
        r.raise_for_status()

        return JsonResponse({
            "status": "processing",
            "redirect": f"/feedback/{session_id}"
        })


    except Exception as e:
        return JsonResponse({"error": f"Failed to trigger FastAPI: {e}"}, status=500)


def feedback(request, session_id):
    try:
        r = requests.get(f"{FASTAPI_URL}/get_feedback/{session_id}")
        r.raise_for_status()
        raw_feedback = r.json().get("feedback", "")
    except Exception as e:
        raw_feedback = f"Error fetching feedback: {e}"

    # ----------------------------
    # PARSE FEEDBACK INTO STRUCTURED BLOCKS
    # ----------------------------
    blocks = []
    parts = raw_feedback.split("<b>")

    for part in parts:
        if "</b>" in part:
            heading, content = part.split("</b>", 1)
            blocks.append({
                "heading": heading.strip(),
                "content": content.strip()
            })

    return render(request, "feedback.html", {
        "blocks": blocks,
        "session_id": session_id
    })

